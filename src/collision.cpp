#include <float.h>
#include <lspe/collision.h>

namespace lspe
{

namespace collision
{

using namespace lspe::shape;

vec2 supportLine(Shape x, const vec2 &direction)
{
	auto p = (Line*)x;
	LSPE_ASSERT(p->type >= 0 && p->type <= 2);
	LSPE_ASSERT(!(p->pa == p->pb));

	float t1 = dot(p->pa, direction);
	float t2 = dot(p->pb, direction);

	return t1 > t2 ? p->pa : p->pb;
}

vec2 supportCircle(Shape x, const vec2 &direction)
{
	auto p = (Circle*)x;
	LSPE_ASSERT(p->r > 0);

	return direction.normalized() * p->r + p->center;
}

vec2 supportPolygen(Shape x, const vec2 &direction)
{
	auto p = (Polygen*)x;
	LSPE_ASSERT(p->vertices.size() >= 3);

	auto &v = p->vertices;
	int index = 0, i;

	float maxval = dot(direction, v[0]);
	for (int i = 1; i < v.size(); ++i)
	{
		float val = dot(direction, v[i]);
		if (val > maxval)
		{
			maxval = val;
			index = i;
		}
	}

	return v[index];
}

vec2 supportEllipse(Shape x, const vec2 &direction)
{
	auto p = (Ellipse*)x;
	LSPE_ASSERT(p->rx > 0 && p->ry > 0);

	mat2x2 mat_rotation = getRotateMatrix(p->rotation);
	mat2x2 mat_invrotation = getRotateMatrix(-p->rotation);

	vec2 rd = (mat_invrotation * direction).normalized();
	vec2 ans = { rd.x * p->rx, rd.y * p->ry };

	return mat_rotation * ans + p->center;
}

vec2 supportBezier2(Shape x, const vec2 &direction)
{
	auto p = (Bezier2*)x;

	return p->P[0];
}

vec2 supportBezier3(Shape x, const vec2 &direction)
{
	auto p = (Bezier3*)x;

	return p->P[0];
}

};

static inline vec2 perpendicularFromOrigin(vec2 a, vec2 b);
bool processSimplex2(vec2 &direction, vec2 *simplex);
bool processSimplex3(vec2 &direction, vec2 *simplex);

using namespace collision;

Collider::Collider()
	: tested(false), iscollided(false),
	flag(0)
{
	shapes[0] = nullptr;
	shapes[1] = nullptr;

	getfirstdirection = nullptr;

	support[0] = nullptr;
	support[1] = nullptr;

	extra = nullptr;
}

vec2 perpendicularFromOrigin(vec2 a, vec2 b)
{
	vec2 ab = b - a;
	float sqab = dot(ab, ab);

	if (sqab < FLT_EPSILON)
	{
		LSPE_DEBUG("perpendicularFromOrigin: bad input line");
		return a;
	} else
	{
		return a + ab * (dot(-a, ab) / sqab);
	}
}

/********************************
 *  @author: ZYmelaii
 *
 *  @Collider: Collider::collided()
 *
 *  @brief: detect whether two objects collide
 *
 *  @NOTES: apply GJK algorithm
 *******************************/

bool Collider::collided()
{
	LSPE_ASSERT(flag == 0x1f);

	vec2 d = getfirstdirection(shapes[0], shapes[1], d, extra);
	if (dot(d, d) < FLT_EPSILON)
	{
		d = { 1.0f, 0.0f };
		LSPE_DEBUG("Collision Test: take (1, 0) as the first direction");
	};

	int n = 0;
	simplex[n++] = support[0](shapes[0], d) - support[1](shapes[1], -d);

	d = -d;

	int iteration = 0;
	while (iteration++ < 16)
	{
		if (dot(d, d) < FLT_EPSILON) //! <=> d.norm() == 0
		{
			LSPE_DEBUG(
				"Collision Test Result: "
				"ORIGIN IS ON SIMPLEX EDGES (iteration=%d)",
				iteration + 1);
			tested = true;
			iscollided = true;
			LSPE_ASSERT(n == 3);
			return iscollided;
		}

		simplex[n++] = support[0](shapes[0], d) - support[1](shapes[1], -d);

		if (dot(simplex[n - 1], d) < 0)
		{
			LSPE_DEBUG(
				"Collision Test Result: "
				"UNEXPECTED SIMPLEX POINT (iteration=%d)",
				iteration + 1);
			tested = true;
			iscollided = false;
			return iscollided;
		}

		if (containOrigin(d, simplex, n))
		{
			LSPE_DEBUG(
				"Collision Test Result: "
				"PASS (iteration=%d)",
				iteration + 1);
			tested = true;
			iscollided = true;
			LSPE_ASSERT(n == 3);
			return iscollided;
		}

		if (n == 3)
		{
			--n;
		}
	}

	LSPE_DEBUG("Collision Test FAILED! (iterations >= %d)", iteration - 1);
	LSPE_DEBUG(
		"LAST ITERATION: direction=(%f,%f); "
		"Simplex={(%f,%f),(%f,%f),(%f,%f)};",
		d.x, d.y,
		simplex[0].x, simplex[0].y,
		simplex[1].x, simplex[1].y,
		simplex[2].x, simplex[2].y);

	return false;
}

/********************************
 *  @author: ZYmelaii
 *
 *  @Collider: Collider::computePenetration()
 *
 *  @brief: compute the penetration vector of
 *          the collided objects
 *
 *  @NOTES: apply EPA algorithm
 *******************************/
vec2 Collider::computePenetration()
{
	LSPE_ASSERT(flag == 0x1f);
	LSPE_ASSERT(tested);

	//! adopt Expanding Polytope Algorithm (EPA)

	//! Minkowski difference set
	using MinkowskiDiffSet = std::vector<vec2>;

	//! edges of Minkowski difference set
	//! MetaEdge.edge = M[fromId[1]] - M[fromId[0]]
	//! MetaEdge.distance = MetaEdge.edge.norm()
	struct MetaEdge { vec2 edge; int fromId[2]; float distance; };
	using Edges = std::vector<MetaEdge>;

	//! indicies for MinkowskiDiffSet and Edges
	//! let I = Indicies, E = Edges
	//! then { E[I[i]] } is a sequence in descended by distance
	using Indicies = std::vector<int>;

	MinkowskiDiffSet M(3);
	Edges E(3);
	Indicies I(3);

	//! add simplex points generated by GJK
	M[0] = simplex[0];
	M[1] = simplex[1];
	M[2] = simplex[2];

	//! initialize edges
	E[0].fromId[0] = 0;
	E[0].fromId[1] = 1;
	
	E[1].fromId[0] = 1;
	E[1].fromId[1] = 2;
	
	E[2].fromId[0] = 2;
	E[2].fromId[1] = 0;

	E[0].edge = M[1] - M[0];
	E[1].edge = M[2] - M[1];
	E[2].edge = M[0] - M[2];

	E[0].distance = perpendicularFromOrigin(M[E[0].fromId[0]], M[E[0].fromId[1]]).norm();
	E[1].distance = perpendicularFromOrigin(M[E[1].fromId[0]], M[E[1].fromId[1]]).norm();
	E[2].distance = perpendicularFromOrigin(M[E[2].fromId[0]], M[E[2].fromId[1]]).norm();

	//! initialize indicies
	I[0] = 0;
	I[1] = 1;
	I[2] = 2;

	std::sort(I.begin(), I.end(), [E](int a, int b) {
		return E[a].distance < E[b].distance;
	});

	//! calculate direction vector deviating from the origin
	//! v0 restores the previous direction vector
	vec2 a = M[E[I[0]].fromId[0]];
	vec2 b = M[E[I[0]].fromId[1]];
	vec2 v = perpendicularFromOrigin(a, b), v0;

	const float epsilon = 0.01f;

	const size_t maxIteration = 16;
	size_t iteration = 0;
	while (iteration++ < maxIteration)
	{
		v0 = v;

		vec2 direction = v.normalized();
		vec2 P = support[0](shapes[0], direction)
			- support[1](shapes[1], -direction);

		if (dot(direction, P) < 0)
		{
			LSPE_DEBUG(
				"computePenetration: "
				"bad new Minkowski point "
				"(P isn't on the expected direction)");
			v = { 0 , 0 };
			break;
		}

		if ((P - a).norm() + (b - P).norm() < epsilon)
		{
			LSPE_DEBUG(
				"computePenetration: "
				"wead new Minkowski point "
				"(points difference is within epsilon)");
			break;
		}

		//! as EPA finally generates a convex hull
		//! P is supposed to break the edge constructed by a and b
		//! new edges respectively constructed by a and P, P and b
		//! will be orderly inserted into E

		M.push_back(P);

		MetaEdge aP, Pb;

		aP.edge      = P - a;
		aP.fromId[0] = E[I[0]].fromId[0];
		aP.fromId[1] = M.size() - 1;
		aP.distance  = perpendicularFromOrigin(M[aP.fromId[0]], M[aP.fromId[1]]).norm();

		Pb.edge      = b - P;
		Pb.fromId[0] = M.size() - 1;
		Pb.fromId[1] = E[I[0]].fromId[1];
		Pb.distance  = perpendicularFromOrigin(M[Pb.fromId[0]], M[Pb.fromId[1]]).norm();

		E[I[0]] = aP;
		E.push_back(Pb);

		int n = E.size() - 1;

		I.push_back(n);

		std::sort(I.begin(), I.end(), [E](int a, int b) {
			return E[a].distance < E[b].distance;
		});

		//! update direction vector
		a = M[E[I[0]].fromId[0]];
		b = M[E[I[0]].fromId[1]];

		if (dot(b - a, b - a) < FLT_EPSILON)
		{
			LSPE_DEBUG(
				"computePenetration: "
				"direction vector is approaching zero");
			break;
		}
		v = perpendicularFromOrigin(a, b);

		if ((v - v0).norm() < epsilon)
		{
			LSPE_DEBUG(
				"computePenetration: "
				"difference of penetration vector is within epsilon");
			break;
		}

	};

#ifdef DEBUG
	if (iteration >= maxIteration)
	{
		LSPE_DEBUG("computePenetration: reach max interation");
		v = { 0, 0 };
	}
#endif

	LSPE_DEBUG(
		"Compute Penetration Result: "
		"(%f, %f) (iteration=%d)",
		v.x, v.y, iteration - 1);

	M.clear();
	E.clear();
	I.clear();

	if (std::isnan(v.x) || std::isnan(v.y))
	{
		return { 0, 0 };
	} else
	{
		return v;
	}
}

void Collider::setTestPair(Shape a, Shape b)
{
	if (a != nullptr)
	{
		shapes[0] = a;
		flag |= 0x01;
	}

	if (b != nullptr)
	{
		shapes[1] = b;
		flag |= 0x02;
	}
}

void Collider::bindSupports(fnsupport support1, fnsupport support2)
{
	if (support1 != nullptr)
	{
		support[0] = support1;
		flag |= 0x04;
	}

	if (support2 != nullptr)
	{
		support[1] = support2;
		flag |= 0x08;
	}
}

void Collider::bindInitialGenerator(fnsupport2 generator)
{
	if (generator != nullptr)
	{
		getfirstdirection = generator;
		flag |= 0x10;
	}
}

void Collider::bindExtraData(void *extra)
{
	this->extra = extra;
}

void* Collider::getExtraData()
{
	return extra;
}

void Collider::reset()
{
	tested = false;
	iscollided = false;
}

bool processSimplex2(vec2 &direction, vec2 *simplex)
{
	LSPE_ASSERT(simplex != nullptr);

	vec2 a = simplex[0];
	vec2 b = simplex[1];

	vec2 ao =   - a;
	vec2 ab = b - a;

	vec2 ab_perp = triproduct(ab, ao, ab);
	direction = ab_perp.normalized();

	return false;
}

bool processSimplex3(vec2 &direction, vec2 *simplex)
{
	LSPE_ASSERT(simplex != nullptr);

	vec2 &a = simplex[0];
	vec2 &b = simplex[1];
	vec2 &c = simplex[2];

	vec2 ao =   - a;
	vec2 ab = b - a;
	vec2 ac = c - a;

	vec2 ab_perp = triproduct(ac, ab, ab);
	vec2 ac_perp = triproduct(ab, ac, ac);

	if (dot(ao, ab_perp) > 0)
	{
		direction = ab_perp.normalized();
	} else if (dot(ao, ac_perp) > 0)
	{
		b = c;
		direction = ac_perp.normalized();
	} else
	{
		return true;
	}

	return false;
}

bool Collider::containOrigin(vec2 &direction, vec2 *simplex, int n)
{
	switch (n)
	{
		case 2: return processSimplex2(direction, simplex);
		case 3: return processSimplex3(direction, simplex);
		default: LSPE_ASSERT(false); //! illegal entry
	}

	LSPE_ASSERT(false);
	return false;
}

};
